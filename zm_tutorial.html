<html>
    <head>
      <meta name="keywords" content="0MQ, ZeroMQ, C++, multipart, message, library, open source, ZmqMessage" />
      <meta name="description" content="ZmqMessage is free open source C++ library for sending and receiving ZeroMQ multipart messages"/>
      <meta name="google-site-verification" content="0EvtpfjffSrc0fDV9ubKQVfq3IV55KY5d59hXHg9M34" />
      <title>ZmqMessage: </title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
<style>
/* must override a few items to get the style background color */

</style>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25607292-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

    </head>
    <body>

<table class="zm_headbar">
<tr>
<td>
  <span><a href="index.html">Overview</a></span>
  <span><a href="zm_tutorial.html">Tutorial</a></span>
  <span><a href="namespaceZmqMessage.html">API reference</a></span>
  <span><a href="examples.html">Examples</a></span>
  <span><a href="zm_build.html">Build</a></span>
  <span><a href="https://github.com/zmqmessage/zmqmessage/">Download</a></span>
</td>

<td align="right" class="zm_greynote">ZmqMessage 0.1 - 21 Oct 2011</td>

</tr></table>

<hr style="height: 3px;">
<!-- Generated by Doxygen 1.4.7 -->
<h2>Tutorial</h2>
<p>
<div class="zm_toc"> <ul>
<li>
<a class="el" href="zm_tutorial.html#ref_configuring">Configuring library to integarte smoothly into your application</a> </li>
<li>
<a class="el" href="zm_tutorial.html#ref_linking_options">Linking options</a> </li>
<li>
<a class="el" href="zm_tutorial.html#ref_receiving">Receiving messages</a> </li>
<li>
<a class="el" href="zm_tutorial.html#ref_sending">Sending messages</a> </li>
</ul>
</div><p>
<hr>
<p>
<a class="anchor" name="ref_configuring"></a> <h3>Configuring library</h3>
<p>
To integrate the library into your application you can (and encouraged to) define a few macro constants before including library headers (<a class="el" href="ZmqMessage_8hpp.html">ZmqMessage.hpp</a> and <a class="el" href="ZmqTools_8hpp.html">ZmqTools.hpp</a>) anywhere in your application. <a class="el" href="ZmqMessageFwd_8hpp.html">ZmqMessageFwd.hpp</a> may be included wherever (i.e. before the definitions). Though none of these definitions are mandatory.<p>
These constants are:<p>
<ul>
<li>
<div class="fragment"><pre class="fragment"><a class="code" href="Config_8hpp.html#4c1baa6349b90bb0dc128873a3c282fc">ZMQMESSAGE_STRING_CLASS</a>
</pre></div> Class that is default string representation. Must satisfy the requirements of the string concept. String concept requires a class to be both constructible on const char* and size_t and have data() and length() accessor methods: <div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyString
 {
  MyString(<span class="keyword">const</span> <span class="keywordtype">char</span>*, size_t);
  <span class="keyword">const</span> <span class="keywordtype">char</span>* data() <span class="keyword">const</span>;
  size_t length() <span class="keyword">const</span>;
 };
</pre></div> It's possible (and desirable) for it not to copy and own the memory, but just wrap the external memory region. For example, take a look at <a class="el" href="classStringFace.html">StringFace</a> class from examples. By default, std::string is used. You may define this setting both if you are linking against shared library or using library as built-in (see <a class="el" href="zm_tutorial.html#ref_linking_options">linking options</a>) <p>
</li>
<li>
<div class="fragment"><pre class="fragment"><a class="code" href="PerfTest_8cpp.html#0d22ae98167989fabf628d43f94b923f">ZMQMESSAGE_LOG_STREAM</a>
</pre></div> Variable or macro to stream log messages to (with operator &lt;&lt;). This enables you to adapt <a class="el" href="namespaceZmqMessage.html">ZmqMessage</a> to you logging system. By default, std::cerr is used (when NDEBUG macro is set), otherwise <a class="el" href="namespaceZmqMessage.html">ZmqMessage</a> is silent. If you want to disable logging even for debug builds, use <a class="el" href="Config_8hpp.html#8769c6cb38fa7dba84a6554cbb8641e8">ZMQMESSAGE_LOG_STREAM_NONE</a> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #define ZMQMESSAGE_LOG_STREAM ZMQMESSAGE_LOG_STREAM_NONE</span>
</pre></div> Note, that this constant is overridable either for application builds without shared library or during compiling shared library. Defining this setting in your application headers during building with shared library takes no effect. <p>
</li>
<li>
<div class="fragment"><pre class="fragment"><a class="code" href="Config_8hpp.html#8e9c1420bf7e575af14c594795c4d9c0">ZMQMESSAGE_LOG_TERM</a>
</pre></div> Streamable literal that is appended (&lt;&lt;) to every log record. If your logging system doesn-t require terminal (such as new line) you can <div class="fragment"><pre class="fragment"><span class="preprocessor"> #define ZMQMESSAGE_LOG_TERM ""</span>
</pre></div> Note, that this constant is overridable either for application builds without shared library or during compiling shared library. Defining this setting in your application headers during building with shared library takes no effect. <p>
</li>
<li>
<div class="fragment"><pre class="fragment"><a class="code" href="Config_8hpp.html#437a821081a9a1d4a9e4515afcc76a17">ZMQMESSAGE_EXCEPTION_MACRO</a>
</pre></div> Macro to generate exception class definition by exception name. It enables you to adapt <a class="el" href="namespaceZmqMessage.html">ZmqMessage</a> to you application exception policy (and hierarchy). By default, we generate simple derivative from std::logic_error. Note, that final semicolon (';') will be appended at end where macro is used, so it's not needed in macro definition. Note, that this constant is overridable either for application builds without shared library or during compiling shared library. <p>
</li>
<li>
<div class="fragment"><pre class="fragment"><a class="code" href="Config_8hpp.html#520d00f537999b0db0acbdce717acb56">ZMQMESSAGE_WRAP_ZMQ_ERROR</a>
</pre></div> if defined, <code>zmq::error_t</code> will be wrapped with exception generated according to <a class="el" href="Config_8hpp.html#437a821081a9a1d4a9e4515afcc76a17">ZMQMESSAGE_EXCEPTION_MACRO</a> and named <code>ZmqException</code>. Otherwise, it's thrown upwards as is. For non header-only builds must be the same in shared library and client code, just like <a class="el" href="Config_8hpp.html#437a821081a9a1d4a9e4515afcc76a17">ZMQMESSAGE_EXCEPTION_MACRO</a> <p>
</li>
</ul>
<p>
<a class="anchor" name="ref_linking_options"></a> <h3>Linking options</h3>
<p>
<ol>
<li>
You may build <a class="el" href="namespaceZmqMessage.html">ZmqMessage</a> as shared library (see <a class="el" href="zm_build.html">build instructions</a>) and link against it. But if you need extensive configuration, the following problem may arise: library is built separately, with definite and basically default configuration (<a class="el" href="PerfTest_8cpp.html#0d22ae98167989fabf628d43f94b923f">ZMQMESSAGE_LOG_STREAM</a>, <a class="el" href="Config_8hpp.html#437a821081a9a1d4a9e4515afcc76a17">ZMQMESSAGE_EXCEPTION_MACRO</a>, <a class="el" href="Config_8hpp.html#520d00f537999b0db0acbdce717acb56">ZMQMESSAGE_WRAP_ZMQ_ERROR</a>), So if you need to override them in your application, you really need to <a class="el" href="zm_build.html">rebuild shared library</a> with appropriate definitions (the same as you define in your application), otherwise you can get the link error as following: <div class="fragment"><pre class="fragment">In function `__static_initialization_and_destruction_0':
/home/andrey_skryabin/projects/zmqmessage/include/zmqmessage/TypeCheck.hpp:32: undefined reference to `<a class="code" href="structZmqMessage_1_1Private_1_1TypeCheck.html">ZmqMessage::Private::TypeCheck&lt;ZmqMessage::MessageFormatError, ZmqMessage::NoSuchPartError, zmq::error_t&gt;::value</a>'
collect2: ld returned 1 exit status
</pre></div> That's because we check that generated types are the same. Link with shared library if you don't need extensive configuration or if it's not too cumbersome for you to rebuild shared library with the same configuration.  </li>
<li>
Do not link against shared library. In this case you MUST include implementation code in ONE of your .cpp files in order to assemble you binary: <div class="fragment"><pre class="fragment"><span class="comment">//@file foo.cpp</span>

<span class="comment">//make definitions available for linking</span>
<span class="preprocessor">#include "<a class="code" href="ZmqMessageImpl_8hpp.html">ZmqMessageImpl.hpp</a>"</span>

...
</pre></div> Do not include "ZmqMessageImpl.hpp" on more than one .cpp file, or you will get multiple definitions and thus link error.<p>
Such approach is better than header-only, cause it reduces compilation time.<p>
</li>
</ol>
<p>
<a class="anchor" name="ref_receiving"></a> <h3>Receiving messages</h3>
<p>
To receive multipart message, you create instance of <a class="el" href="classZmqMessage_1_1Incoming.html">ZmqMessage::Incoming</a>. For XREQ and XREP socket types use <a class="el" href="classZmqMessage_1_1XRouting.html">ZmqMessage::XRouting</a> as template parameter, for other socket types use <a class="el" href="classZmqMessage_1_1SimpleRouting.html">ZmqMessage::SimpleRouting</a>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="ZmqMessage_8hpp.html">ZmqMessage.hpp</a>"</span>

zmq::context_t <a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>(1);
zmq::socket sock(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_PULL); <span class="comment">//will use SimpleRouting</span>
sock.connect(<span class="stringliteral">"inproc://some-endpoint"</span>);

<a class="code" href="classZmqMessage_1_1Incoming.html">ZmqMessage::Incoming&lt;ZmqMessage::SimpleRouting&gt;</a> incoming(sock);

<span class="comment">//say, we know what message parts we receive. Here are their names:</span>
<span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="PerfTest_8cpp.html#5b06fc00200013a9ce624c5b5730d407">req_parts</a>[] = {<span class="stringliteral">"id"</span>, <span class="stringliteral">"name"</span>, <span class="stringliteral">"blob"</span>};

<span class="comment">//true because it's a terminal message, no more parts allowed at end</span>
incoming.receive(3, req_parts, <span class="keyword">true</span>);

<span class="comment">//Get 2nd part explicitly (assume ZMQMESSAGE_STRING_CLASS is std::string):</span>
std::string name = <a class="code" href="namespaceZmqMessage.html#81ef09fe85119d2a4853f2c7ec17481e">ZmqMessage::get_string</a>(incoming[1]);
<span class="comment">//or more verbose:</span>
std::string name_cpy = ZmqMessage::get&lt;std::string&gt;(incoming[1]);

<span class="comment">//if we also have some MyString class:</span>
MyString my_id = ZmqMessage::get&lt;MyString&gt;(incoming[0]);

<span class="comment">//or we can extract data as variables or plain zmq messages.</span>
zmq::message_t blob;
incoming &gt;&gt; my_id &gt;&gt; name &gt;&gt; blob;

<span class="comment">//or we can iterate on message parts and use standard algorithms:</span>
std::ostream_iterator&lt;MyString&gt; out_it(std::cout, <span class="stringliteral">", "</span>);
std::copy(
  incoming.begin&lt;MyString&gt;(), incoming.end&lt;MyString&gt;(), out_it);
</pre></div><p>
Of course, passing message part names is not necessary (see <a class="el" href="classZmqMessage_1_1Incoming.html#73949e905ee75e4c46f40419a8c7a2b2">receive</a> functions).<p>
There are cases when implemented protocol implies a fixed number of message parts at the beginning of multipart message. And the number of subsequent messages is either undefined or estimated based on contents of first parts (i.e. first part may contain command name, and other parts may contain data dependent on command). So you first may call <a class="el" href="classZmqMessage_1_1Incoming.html#73949e905ee75e4c46f40419a8c7a2b2">receive</a> function with <code>false</code> as last parameter (not checking if message is terminal), do something with first parts, and then call <a class="el" href="classZmqMessage_1_1Incoming.html#73949e905ee75e4c46f40419a8c7a2b2">receive</a> or <a class="el" href="classZmqMessage_1_1Incoming.html#fe9c095eb689f7682073dc1b211752b4">receive_all</a> again to fetch the rest.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span>* req_parts[] = {<span class="stringliteral">"command"</span>};
incoming.receive(1, req_parts, <span class="keyword">false</span>);

std::string cmd = <a class="code" href="namespaceZmqMessage.html#81ef09fe85119d2a4853f2c7ec17481e">ZmqMessage::get_string</a>(incoming[0]);

<span class="keywordflow">if</span> (cmd == <span class="stringliteral">"SET_PARAM"</span>)
{
  <span class="keyword">const</span> <span class="keywordtype">char</span>* tail_parts[] = {<span class="stringliteral">"parameter 1 value (text)"</span>, <span class="stringliteral">"parameter 2 value (binary)"</span>};
  incoming.receive(2, tail_parts, <span class="keyword">true</span>);

  <span class="comment">//message with parameter 1 contains text data converted into unsigned 32 bit integer (ex. "678" -&gt; 678)</span>
  uint32_t param1 = ZmqMessage::get&lt;uint32_t&gt;(incoming[1]);

  <span class="comment">//message with parameter 2 contains binary data (unsigned 32 bit integer)</span>
  uint32_t param2 = ZmqMessage::get_bin&lt;uint32_t&gt;(incoming[2]);
  <span class="comment">//or this way (second parameter defines binary/text mode)</span>
  uint32_t param2_copy = ZmqMessage::get&lt;uint32_t&gt;(incoming[2], <span class="keyword">true</span>);

  <span class="comment">//...</span>
}
<span class="keywordflow">else</span>
{
  <span class="comment">//otherwise we receive all remaining message parts</span>
  incoming.receive_all();

  <span class="keywordflow">if</span> (incoming.size() &gt; 1)
  {
    std::string first;
    incoming &gt;&gt; <a class="code" href="namespaceZmqMessage.html#d8492b4bc52a3bb1d316e67ba790a354">ZmqMessage::Skip</a> <span class="comment">//command is already analyzed</span>
      &gt;&gt; first; <span class="comment">// same as first = ZmqMessage::get&lt;std::string&gt;(incoming[1]);</span>
    <span class="comment">//...</span>
  }
}
</pre></div><p>
<a class="anchor" name="ref_sending"></a> <h3>Sending messages</h3>
<p>
To send a multipart message, you create instance of <a class="el" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing</a>. For sending to XREQ and XREP socket types use <a class="el" href="classZmqMessage_1_1XRouting.html">ZmqMessage::XRouting</a> as template parameter, for other socket types use <a class="el" href="classZmqMessage_1_1SimpleRouting.html">ZmqMessage::SimpleRouting</a>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="ZmqMessage_8hpp.html">ZmqMessage.hpp</a>"</span>

zmq::context_t <a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>(1);
zmq::socket sock(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_XREQ); <span class="comment">//will use XRouting</span>
sock.connect(<span class="stringliteral">"inproc://some-endpoint"</span>);

<span class="comment">//create Outgoing specifying sending options: use nonblocking send</span>
<span class="comment">//and drop messages if operation would block</span>
<a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::XRouting&gt;</a> outgoing(
  sock, <a class="code" href="structZmqMessage_1_1OutOptions.html#ada297235a6adb7dc637eab6e8cbe1b3">ZmqMessage::OutOptions::NONBLOCK</a> | <a class="code" href="structZmqMessage_1_1OutOptions.html#90fc3863c646724d897d30fcde3aff73">ZmqMessage::OutOptions::DROP_ON_BLOCK</a>);

<span class="comment">//suppose we have some MyString class:</span>
MyString id(<span class="stringliteral">"112233"</span>);

outgoing &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">"SET_VARIABLES"</span>;

<span class="comment">//Number will be converted to string (written to stream), cause Outgoing is in Text mode.</span>
outgoing &lt;&lt; 567099;

<span class="keywordtype">char</span> buffer[128];
::memset (buffer, <span class="charliteral">'z'</span>, 128); <span class="comment">//fill buffer</span>

outgoing &lt;&lt; <a class="code" href="structZmqMessage_1_1RawMessage.html">ZmqMessage::RawMessage</a>(buffer, 128);

<span class="comment">//send message with binary number and flush it;</span>
<span class="keywordtype">int</span> num = 9988;
outgoing &lt;&lt; ZmqMessage::Binary &lt;&lt; num &lt;&lt; ZmqMessage::Flush;
</pre></div><p>
Note, that Outgoing template class is derived from <a class="el" href="classZmqMessage_1_1Sink.html">ZmqMessage::Sink</a> class, and all the functionality for inserting and sending messages is encapsulated there. It's done that way because Outgoing depends on RoutingPolicy template parameter only on construction and implicit sending of routing message parts, so after creation, Outgoing may be referenced as non-template Sink (passed to functions, etc.): <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> send_parts(<a class="code" href="classZmqMessage_1_1Sink.html">ZmqMessage::Sink</a>&amp; sink)
{
  sink &lt;&lt; <span class="stringliteral">"some data"</span> &lt;&lt; 5678 &lt;&lt; ZmqMessage::Flush;
}

<span class="keywordtype">int</span> <a class="code" href="zasync_8cpp.html#4b097df32a52205a4c919b840eba55fc">main</a>()
{
  <a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::XRouting&gt;</a> outgoing(...);

  send_parts(outgoing);

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
Flushing Outgoing message sends final (terminal) message part (which was inserted before flushing), and no more insertions allowed after it. If you do not flush Outgoing message manually, it will flush in destructor. 
<hr style="height: 3px;">

<div class="zm_greynote">
ZmqMessage 0.1 &mdash; open source software, <a href="mailto:support@zmqmessage.org">support@zmqmessage.org</a>
</div>

</body>
</html>
