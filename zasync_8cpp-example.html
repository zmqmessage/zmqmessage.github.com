<html>
    <head>
      <meta name="keywords" content="0MQ, ZeroMQ, C++, multipart, message, library, open source, ZmqMessage" />
      <meta name="description" content="ZmqMessage is free open source C++ library for sending and receiving ZeroMQ multipart messages"/>
      <meta name="google-site-verification" content="0EvtpfjffSrc0fDV9ubKQVfq3IV55KY5d59hXHg9M34" />
      <title>ZmqMessage: zasync.cpp</title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
<style>
/* must override a few items to get the style background color */

</style>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25607292-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

    </head>
    <body>

<table class="zm_headbar">
<tr>
<td>
  <span><a href="index.html">Overview</a></span>
  <span><a href="zm_tutorial.html">Tutorial</a></span>
  <span><a href="namespaceZmqMessage.html">API reference</a></span>
  <span><a href="examples.html">Examples</a></span>
  <span><a href="zm_build.html">Build</a></span>
  <span><a href="https://github.com/zmqmessage/zmqmessage/">Download</a></span>
</td>

<td align="right" class="zm_greynote">ZmqMessage 0.1 - 8 Sep 2011</td>

</tr></table>

<hr style="height: 3px;">
<!-- Generated by Doxygen 1.4.7 -->
<h1>zasync.cpp</h1>This example emulates processing of asynchronous tasks in a separate thread. Tasks and their results are received and sent via ZMQ. HWM (high watermark) along with queueing and delayed sending is used to avoid congestion of execution thread, blocking and losing any of processing results.<p>
Characteristics of task processing: <ul>
<li>
Tasks are composed of random number of 'steps'. </li>
<li>
All tasks are processed concurrently, step-by-step (actually we decrement step counter each second when thread is idle). </li>
</ul>
In real life tasks would be execution of a series of remote requests, launching processes, IO operations or whatever.<p>
Execution thread behavior is following: <ul>
<li>
We have a separate results queue for delayed execution. When a task has been processed and we failed to send result with no blocking (ZMQ internal queue is full) the message is put to delayed queue.  </li>
<li>
We are accepting new tasks for execution ONLY when our results queue is empty (so task sender thread is able to detect clobbering if it's not able to send request with no blocking).  </li>
<li>
We are polling result channel for writing if queue is not empty (to send delayed messages when possible).  </li>
</ul>
<p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00011"></a>00011 <span class="preprocessor">#include "pthread.h"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "stdint.h"</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include "<a class="code" href="ZmqMessage_8hpp.html">ZmqMessage.hpp</a>"</span>
<a name="l00016"></a>00016 
<a name="l00047"></a>00047 <span class="comment">//0mq context is globally available</span>
<a name="l00048"></a>00048 zmq::context_t <a name="a0"></a><a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>(1);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">// endpoints to pass data from main thread to worker and back</span>
<a name="l00051"></a>00051 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a name="a1"></a><a class="code" href="zasync_8cpp.html#70bb72dad4c860bff2238e882ceadb82">req_endpoint</a> = <span class="stringliteral">"inproc://req_ep"</span>;
<a name="l00052"></a>00052 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a name="a2"></a><a class="code" href="zasync_8cpp.html#a7ed7672c8f8f848c28dabff90dd379b">res_endpoint</a> = <span class="stringliteral">"inproc://res_ep"</span>;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">// endpoint to publish stop signal, we shouldn't miss it!</span>
<a name="l00055"></a>00055 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a name="a3"></a><a class="code" href="zasync_8cpp.html#3ff515ef0c34ec454728eb7193196397">stop_endpoint</a> = <span class="stringliteral">"inproc://stop"</span>;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a name="a4"></a><a class="code" href="zasync_8cpp.html#ff5265b06e3b4c15fbdf9ade25702459">to_worker_fields</a>[] = {<span class="stringliteral">"message_type"</span>, <span class="stringliteral">"task_identifier"</span>};
<a name="l00058"></a>00058 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a name="a5"></a><a class="code" href="zasync_8cpp.html#e148bfbaaf1b41e66e3d8e919617464a">from_worker_fields</a>[] = {<span class="stringliteral">"message_type"</span>, <span class="stringliteral">"task_identifier"</span>};
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 uint64_t <a name="a6"></a><a class="code" href="zasync_8cpp.html#bb2759d76ff59ab76b83a668b81826f8">message_queue_limit</a> = 5;
<a name="l00061"></a>00061 <span class="keywordtype">int</span> <a name="a7"></a><a class="code" href="zasync_8cpp.html#11a35c131ff5a1f54172a8e083cb205c">max_task_steps</a> = 10;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">//we emulate asynchronous tasks by decrementing counter on each poll timeout event</span>
<a name="l00064"></a>00064 <span class="keyword">struct </span><a name="_a8"></a><a class="code" href="structasync__task.html">async_task</a>
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066   <span class="keywordtype">int</span> id;
<a name="l00067"></a>00067   <span class="keywordtype">int</span> remaining_steps;
<a name="l00068"></a>00068 };
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keyword">typedef</span> std::vector&lt;async_task&gt; <a class="code" href="zasync_8cpp.html#c4b626a1e7c2298705a6e1d8c8587d7e">TaskVec</a>;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keywordtype">void</span> <a name="a9"></a><a class="code" href="zasync_8cpp.html#9613bea495be8d44f4eb12f68c83aacd">task_step</a>(<a class="code" href="structasync__task.html">async_task</a>&amp; task)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074   --task.<a name="a10"></a><a class="code" href="structasync__task.html#63bdf8fc193a7c0d305eabcc8f538194">remaining_steps</a>;
<a name="l00075"></a>00075 }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> QueueInserter&gt;
<a name="l00078"></a>00078 <span class="keywordtype">void</span> <a name="a11"></a><a class="code" href="zasync_8cpp.html#be80f95dd9309819875ce8639b786566">run_tasks</a>(<a class="code" href="zasync_8cpp.html#c4b626a1e7c2298705a6e1d8c8587d7e">TaskVec</a>&amp; tasks, zmq::socket_t&amp; s_res, QueueInserter q)
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080   std::for_each(tasks.begin(), tasks.end(), &amp;<a class="code" href="zasync_8cpp.html#9613bea495be8d44f4eb12f68c83aacd">task_step</a>);
<a name="l00081"></a>00081   <span class="keywordflow">for</span> (TaskVec::iterator it = tasks.begin(); it != tasks.end(); )
<a name="l00082"></a>00082   {
<a name="l00083"></a>00083     <a class="code" href="structasync__task.html">async_task</a>&amp; task = *it;
<a name="l00084"></a>00084     <span class="keywordflow">if</span> (task.remaining_steps == 0)
<a name="l00085"></a>00085     {
<a name="l00086"></a>00086       std::cout &lt;&lt; <span class="stringliteral">" task "</span> &lt;&lt; task.id &lt;&lt; <span class="stringliteral">" done"</span> &lt;&lt; std::endl;
<a name="l00087"></a>00087       <a name="_a12"></a><a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::SimpleRouting&gt;</a> egress(
<a name="l00088"></a>00088         <a name="_a13"></a><a class="code" href="structZmqMessage_1_1OutOptions.html">ZmqMessage::OutOptions</a>(
<a name="l00089"></a>00089           s_res, <a name="a14"></a><a class="code" href="structZmqMessage_1_1OutOptions.html#adc74d66130c3ba01e9b74ca425d168b">ZmqMessage::OutOptions::CACHE_ON_BLOCK</a> |
<a name="l00090"></a>00090           <a name="a15"></a><a class="code" href="structZmqMessage_1_1OutOptions.html#ada297235a6adb7dc637eab6e8cbe1b3">ZmqMessage::OutOptions::NONBLOCK</a>));
<a name="l00091"></a>00091 
<a name="l00092"></a>00092       egress &lt;&lt; <span class="stringliteral">"finished"</span> &lt;&lt; task.id &lt;&lt; <a name="a16"></a><a class="code" href="namespaceZmqMessage.html#d91dfdcb44a38c67cb7c8acbf4096a53">ZmqMessage::Flush</a>;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094       <span class="keywordflow">if</span> (egress.is_queued())
<a name="l00095"></a>00095       {
<a name="l00096"></a>00096         std::cout &lt;&lt; <span class="stringliteral">" is_queued"</span> &lt;&lt; std::endl;
<a name="l00097"></a>00097         *q = egress.detach();
<a name="l00098"></a>00098       }
<a name="l00099"></a>00099       it = tasks.erase(it);
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101     <span class="keywordflow">else</span>
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103       ++it;
<a name="l00104"></a>00104     }
<a name="l00105"></a>00105   }
<a name="l00106"></a>00106 }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">// async task processor, runs in a dedicated thread</span>
<a name="l00109"></a>00109 <span class="comment">//Receives 'tasks' designated by id. Each task will take random (1-max_task_steps) steps to complete.</span>
<a name="l00110"></a>00110 <span class="comment">//so 'finished' responses will come in arbitrary order</span>
<a name="l00111"></a>00111 <span class="keywordtype">void</span>*
<a name="l00112"></a>00112 <a name="a17"></a><a class="code" href="zasync_8cpp.html#d3286db3401aa2d7a07d3bc3e3f9524c">async_task_processor</a>(<span class="keywordtype">void</span>*)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114   <span class="keywordflow">try</span>
<a name="l00115"></a>00115   {
<a name="l00116"></a>00116     zmq::socket_t s_req(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_PULL);
<a name="l00117"></a>00117     zmq::socket_t s_res(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_PUSH);
<a name="l00118"></a>00118     uint64_t one_lim = 1;
<a name="l00119"></a>00119     s_req.setsockopt(ZMQ_HWM, &amp;one_lim, <span class="keyword">sizeof</span>(uint64_t));
<a name="l00120"></a>00120     s_res.setsockopt(ZMQ_HWM, &amp;one_lim, <span class="keyword">sizeof</span>(uint64_t));
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     s_req.connect(<a class="code" href="zasync_8cpp.html#70bb72dad4c860bff2238e882ceadb82">req_endpoint</a>);
<a name="l00123"></a>00123     s_res.connect(<a class="code" href="zasync_8cpp.html#a7ed7672c8f8f848c28dabff90dd379b">res_endpoint</a>);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     zmq::socket_t ss(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_SUB);
<a name="l00126"></a>00126     ss.setsockopt (ZMQ_SUBSCRIBE, <span class="stringliteral">""</span>, 0);
<a name="l00127"></a>00127     ss.connect(<a class="code" href="zasync_8cpp.html#3ff515ef0c34ec454728eb7193196397">stop_endpoint</a>);
<a name="l00128"></a>00128     <span class="comment">// socket to receive stop notifications from main thread and to send result back</span>
<a name="l00129"></a>00129     <span class="comment">//   is connected</span>
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     zmq_pollitem_t item[3]; <span class="comment">//stop, in, out</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     item[0].socket = ss;
<a name="l00134"></a>00134     item[0].events = ZMQ_POLLIN;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     item[1].socket = s_req;
<a name="l00137"></a>00137     item[1].events = ZMQ_POLLIN;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     item[2].socket = s_res;
<a name="l00140"></a>00140     item[2].events = ZMQ_POLLOUT;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     std::vector&lt;ZmqMessage::Multipart*&gt; queue;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <a class="code" href="zasync_8cpp.html#c4b626a1e7c2298705a6e1d8c8587d7e">TaskVec</a> tasks;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="keywordflow">for</span>(;;)
<a name="l00147"></a>00147     {
<a name="l00148"></a>00148       <span class="comment">//have something to send</span>
<a name="l00149"></a>00149       item[2].events = (queue.empty()) ? 0 : ZMQ_POLLOUT;
<a name="l00150"></a>00150       <span class="comment">//do not receive more tasks until we send pending responses</span>
<a name="l00151"></a>00151       item[1].events = (queue.empty()) ? ZMQ_POLLIN : 0;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153       <span class="keywordtype">int</span> <a name="a18"></a><a class="code" href="SimpleTest_8cpp.html#1acee2dcd7c3a6241c50a8cfb1dd1f68">res</a> = zmq::poll(item, <span class="keyword">sizeof</span>(item) / <span class="keyword">sizeof</span>(item[0]), 1000000); <span class="comment">//1s</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155       <span class="keywordflow">if</span> (res == 0)
<a name="l00156"></a>00156       {
<a name="l00157"></a>00157         <span class="comment">//timeout</span>
<a name="l00158"></a>00158         std::cout &lt;&lt; <span class="stringliteral">"RUN TASKS: "</span> &lt;&lt; tasks.size() &lt;&lt; std::endl;
<a name="l00159"></a>00159         <a class="code" href="zasync_8cpp.html#be80f95dd9309819875ce8639b786566">run_tasks</a>(tasks, s_res, std::back_inserter(queue));
<a name="l00160"></a>00160         <span class="keywordflow">continue</span>;
<a name="l00161"></a>00161       }
<a name="l00162"></a>00162       <span class="keywordflow">if</span> (item[0].revents) <span class="comment">// stop</span>
<a name="l00163"></a>00163       {
<a name="l00164"></a>00164         std::cout &lt;&lt; <span class="stringliteral">" stop"</span> &lt;&lt; std::endl;
<a name="l00165"></a>00165         <span class="keywordflow">break</span>;
<a name="l00166"></a>00166       }
<a name="l00167"></a>00167       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((item[2].revents &amp; ZMQ_POLLOUT) &amp;&amp; (item[2].revents &amp; ZMQ_POLLOUT))
<a name="l00168"></a>00168       {
<a name="l00169"></a>00169         std::cout &lt;&lt; <span class="stringliteral">"POLLOUT, sending"</span> &lt;&lt; std::endl;
<a name="l00170"></a>00170         std::auto_ptr&lt;ZmqMessage::Multipart&gt; m(queue.back()); <span class="comment">//no throw</span>
<a name="l00171"></a>00171         queue.back() = 0; <span class="comment">//no throw</span>
<a name="l00172"></a>00172         queue.pop_back();
<a name="l00173"></a>00173         <a name="a19"></a><a class="code" href="namespaceZmqMessage.html#4bb46453f21cf21bed2f1d6b546f0fea">ZmqMessage::send</a>(s_res, *m, <span class="keyword">true</span>);
<a name="l00174"></a>00174       }
<a name="l00175"></a>00175       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((item[1].events &amp; ZMQ_POLLIN) &amp;&amp; (item[1].revents &amp; ZMQ_POLLIN))
<a name="l00176"></a>00176       {
<a name="l00177"></a>00177         std::cout &lt;&lt; <span class="stringliteral">"POLLIN, new task"</span> &lt;&lt; std::endl;
<a name="l00178"></a>00178         <a name="_a20"></a><a class="code" href="classZmqMessage_1_1Incoming.html">ZmqMessage::Incoming&lt;ZmqMessage::SimpleRouting&gt;</a> ingress(s_req);
<a name="l00179"></a>00179         ingress.receive(2, <a class="code" href="zasync_8cpp.html#ff5265b06e3b4c15fbdf9ade25702459">to_worker_fields</a>, 2, <span class="keyword">true</span>);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         std::string tmp;
<a name="l00182"></a>00182         <a class="code" href="structasync__task.html">async_task</a> task;
<a name="l00183"></a>00183         ingress &gt;&gt; tmp &gt;&gt; task.<a name="a21"></a><a class="code" href="structasync__task.html#f2f6cb38786ddb6a087e61190426b9d5">id</a>;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185         task.<a class="code" href="structasync__task.html#63bdf8fc193a7c0d305eabcc8f538194">remaining_steps</a> = (rand() % (<a class="code" href="zasync_8cpp.html#11a35c131ff5a1f54172a8e083cb205c">max_task_steps</a> - 1)) + 1; <span class="comment">//1-max_task_steps</span>
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         tasks.push_back(task);
<a name="l00188"></a>00188       }
<a name="l00189"></a>00189     }
<a name="l00190"></a>00190   }
<a name="l00191"></a>00191   <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; ex)
<a name="l00192"></a>00192   {
<a name="l00193"></a>00193     std::cout &lt;&lt; <span class="stringliteral">"caught (processor): "</span> &lt;&lt; ex.what();
<a name="l00194"></a>00194     exit(3);
<a name="l00195"></a>00195   }
<a name="l00196"></a>00196   <span class="keywordflow">return</span> 0;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="keywordtype">int</span>
<a name="l00201"></a>00201 <a name="a22"></a><a class="code" href="zasync_8cpp.html#4b097df32a52205a4c919b840eba55fc">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)
<a name="l00202"></a>00202 {
<a name="l00203"></a>00203   pthread_t worker_tid;
<a name="l00204"></a>00204   pthread_t sender_tid;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206   zmq::socket_t s_req(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_PUSH);
<a name="l00207"></a>00207   zmq::socket_t s_res(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_PULL);
<a name="l00208"></a>00208   s_req.setsockopt(ZMQ_HWM, &amp;<a class="code" href="zasync_8cpp.html#bb2759d76ff59ab76b83a668b81826f8">message_queue_limit</a>, <span class="keyword">sizeof</span>(uint64_t));
<a name="l00209"></a>00209   s_res.setsockopt(ZMQ_HWM, &amp;<a class="code" href="zasync_8cpp.html#bb2759d76ff59ab76b83a668b81826f8">message_queue_limit</a>, <span class="keyword">sizeof</span>(uint64_t));
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   s_req.bind(<a class="code" href="zasync_8cpp.html#70bb72dad4c860bff2238e882ceadb82">req_endpoint</a>);
<a name="l00212"></a>00212   s_res.bind(<a class="code" href="zasync_8cpp.html#a7ed7672c8f8f848c28dabff90dd379b">res_endpoint</a>);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   zmq::socket_t ss(<a class="code" href="zasync_8cpp.html#dfc676557ead71d2d6a26f06c84409fe">ctx</a>, ZMQ_PUB);
<a name="l00215"></a>00215   ss.bind(<a class="code" href="zasync_8cpp.html#3ff515ef0c34ec454728eb7193196397">stop_endpoint</a>);
<a name="l00216"></a>00216   <span class="comment">// socket to talk to worker is bound</span>
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   <span class="keywordflow">try</span>
<a name="l00219"></a>00219   {
<a name="l00220"></a>00220     <span class="comment">// start worker</span>
<a name="l00221"></a>00221     pthread_create(&amp;worker_tid, 0, <a class="code" href="zasync_8cpp.html#d3286db3401aa2d7a07d3bc3e3f9524c">async_task_processor</a>, 0);
<a name="l00222"></a>00222     sleep(1);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="zasync_8cpp.html#bb2759d76ff59ab76b83a668b81826f8">message_queue_limit</a>+2; ++i)
<a name="l00225"></a>00225     {
<a name="l00226"></a>00226       <a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::SimpleRouting&gt;</a> to_worker(s_req, <a class="code" href="structZmqMessage_1_1OutOptions.html#ada297235a6adb7dc637eab6e8cbe1b3">ZmqMessage::OutOptions::NONBLOCK</a>);
<a name="l00227"></a>00227       to_worker &lt;&lt; <span class="stringliteral">"request"</span> &lt;&lt; i &lt;&lt; <a class="code" href="namespaceZmqMessage.html#d91dfdcb44a38c67cb7c8acbf4096a53">ZmqMessage::Flush</a>;
<a name="l00228"></a>00228       usleep(100000);
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     std::cout &lt;&lt; <span class="stringliteral">"1:requests sent: "</span> &lt;&lt; (message_queue_limit+2) &lt;&lt;
<a name="l00232"></a>00232       <span class="stringliteral">", sleeping "</span> &lt;&lt; <a class="code" href="zasync_8cpp.html#11a35c131ff5a1f54172a8e083cb205c">max_task_steps</a> &lt;&lt; std::endl;
<a name="l00233"></a>00233     sleep(<a class="code" href="zasync_8cpp.html#11a35c131ff5a1f54172a8e083cb205c">max_task_steps</a> + 1);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235     <span class="comment">//all tasks are processed, res queue is full, 1 remaining response is cached</span>
<a name="l00236"></a>00236     <span class="comment">//so no new requests is accepted</span>
<a name="l00237"></a>00237     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = message_queue_limit+2; i &lt; 2*message_queue_limit+2; ++i)
<a name="l00238"></a>00238     {
<a name="l00239"></a>00239       <a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::SimpleRouting&gt;</a> to_worker(s_req, <a class="code" href="structZmqMessage_1_1OutOptions.html#ada297235a6adb7dc637eab6e8cbe1b3">ZmqMessage::OutOptions::NONBLOCK</a>);
<a name="l00240"></a>00240       to_worker &lt;&lt; <span class="stringliteral">"request"</span> &lt;&lt; i &lt;&lt; <a class="code" href="namespaceZmqMessage.html#d91dfdcb44a38c67cb7c8acbf4096a53">ZmqMessage::Flush</a>;
<a name="l00241"></a>00241       usleep(100000);
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243     std::cout &lt;&lt; <span class="stringliteral">"2:requests sent: "</span> &lt;&lt; message_queue_limit &lt;&lt; std::endl;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <span class="comment">//req queue filled</span>
<a name="l00246"></a>00246     <a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::SimpleRouting&gt;</a> to_worker(
<a name="l00247"></a>00247       s_req, <a class="code" href="structZmqMessage_1_1OutOptions.html#ada297235a6adb7dc637eab6e8cbe1b3">ZmqMessage::OutOptions::NONBLOCK</a> | <a name="a23"></a><a class="code" href="structZmqMessage_1_1OutOptions.html#90fc3863c646724d897d30fcde3aff73">ZmqMessage::OutOptions::DROP_ON_BLOCK</a>);
<a name="l00248"></a>00248     to_worker &lt;&lt; <span class="stringliteral">"request"</span> &lt;&lt; (2*message_queue_limit+2) &lt;&lt; <a class="code" href="namespaceZmqMessage.html#d91dfdcb44a38c67cb7c8acbf4096a53">ZmqMessage::Flush</a>;
<a name="l00249"></a>00249     assert(to_worker.is_dropping());
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="comment">//read all</span>
<a name="l00252"></a>00252     std::cout &lt;&lt; <span class="stringliteral">"reading..."</span> &lt;&lt; std::endl;
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     std::string msg_type;
<a name="l00255"></a>00255     std::string msg_id;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2*message_queue_limit; ++i)
<a name="l00258"></a>00258     {
<a name="l00259"></a>00259       <a class="code" href="classZmqMessage_1_1Incoming.html">ZmqMessage::Incoming&lt;ZmqMessage::SimpleRouting&gt;</a> from_worker0(s_res);
<a name="l00260"></a>00260       from_worker0.receive(2, <a class="code" href="zasync_8cpp.html#e148bfbaaf1b41e66e3d8e919617464a">from_worker_fields</a>, 2, <span class="keyword">true</span>);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262       from_worker0 &gt;&gt; msg_type &gt;&gt; msg_id;
<a name="l00263"></a>00263       std::cout &lt;&lt; msg_type &lt;&lt; msg_id &lt;&lt; <span class="stringliteral">"received by main thread"</span> &lt;&lt; std::endl;
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266     <span class="comment">//stop</span>
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::SimpleRouting&gt;</a> to_stop(ss, 0);
<a name="l00269"></a>00269     to_stop &lt;&lt; <span class="stringliteral">"stop"</span> &lt;&lt; <a class="code" href="namespaceZmqMessage.html#d91dfdcb44a38c67cb7c8acbf4096a53">ZmqMessage::Flush</a>;
<a name="l00270"></a>00270   }
<a name="l00271"></a>00271     <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; ex)
<a name="l00272"></a>00272   {
<a name="l00273"></a>00273     std::cout &lt;&lt; <span class="stringliteral">"caught (main): "</span> &lt;&lt; ex.what();
<a name="l00274"></a>00274     exit(3);
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   pthread_join(worker_tid, 0);
<a name="l00278"></a>00278 <span class="comment">//  pthread_join(sender_tid, 0);</span>
<a name="l00279"></a>00279   <span class="comment">// thread is completed and sockets are closed</span>
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 
</pre></div> 
<hr style="height: 3px;">

<div class="zm_greynote">
ZmqMessage 0.1 &mdash; open source software, <a href="mailto:support@zmqmessage.org">support@zmqmessage.org</a>
</div>

</body>
</html>
