<html>
    <head>
      <meta name="keywords" content="0MQ, ZeroMQ, C++, multipart, message, library, open source, ZmqMessage" />
      <meta name="description" content="ZmqMessage is free open source C++ library for sending and receiving ZeroMQ multipart messages"/>
      <meta name="google-site-verification" content="0EvtpfjffSrc0fDV9ubKQVfq3IV55KY5d59hXHg9M34" />
      <title>ZmqMessage: </title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
<style>
/* must override a few items to get the style background color */

</style>
    </head>
    <body>

<table class="zm_headbar">
<tr>
<td>
  <span><a href="index.html">Overview</a></span>
  <span><a href="zm_tutorial.html">Tutorial</a></span>
  <span><a href="namespaceZmqMessage.html">API reference</a></span>
  <span><a href="examples.html">Examples</a></span>
  <span><a href="zm_build.html">Build</a></span>
  <span><a href="https://github.com/zmqmessage/zmqmessage/">Download</a></span>
</td>

<td align="right" class="zm_greynote">ZmqMessage 0.1 - 8 Sep 2011</td>

</tr></table>

<hr style="height: 3px;">
<!-- Generated by Doxygen 1.4.7 -->
<h2>Word on Text and Binary modes</h2>
<p>
<hr>
 Text and Binary modes determine how raw ZMQ message content is converted into user type, when message content is extracted from Incoming, inserted into Outgoing, or we iterate over incoming multipart message.<p>
<b>Binary:</b> message content pointer is interpreted as pointer to user type, and assign operator is invoked. This mode is suitable for implementing binary protocols.<p>
<b>Text:</b> message content is interpreted as char array. For string types (see <a class="el" href="Config_8hpp.html#4c1baa6349b90bb0dc128873a3c282fc">ZMQMESSAGE_STRING_CLASS</a> on string concept definition) we initialize object from char array, for other types we put (&gt;&gt;) chars into <code>stringstream</code> and read stream into instance of type.<p>
<h3>How to set:</h3>
<p>
<ul>
<li>
For Incoming: Use Text and Binary manipulators to switch stream to/from binary mode. Default mode is text. <div class="fragment"><pre class="fragment"><span class="comment">//read text command and binary integer as value.</span>
std::string command;
<span class="keywordtype">int</span> value;
incoming &gt;&gt; <a class="code" href="namespaceZmqMessage.html#60e56a3c40f23f5f62705e2c3a15d6a4">ZmqMessage::Text</a> &gt;&gt; command &lt;&lt; <a class="code" href="namespaceZmqMessage.html#8b7a75f7f251ba1e0da8b4c7c26b627f">ZmqMessage::Binary</a> &lt;&lt; value;
</pre></div>  </li>
<li>
For iteration over incoming: Call Incoming::begin() method: <div class="fragment"><pre class="fragment">std::ostream_iterator&lt;int&gt; out_it(std::cout, <span class="stringliteral">", "</span>);

<span class="comment">//print messages with binary integers.</span>
std::copy(
  incoming.begin&lt;<span class="keywordtype">int</span>&gt;(<span class="keyword">true</span>), incoming.end&lt;<span class="keywordtype">int</span>&gt;(), out_it);
</pre></div>  </li>
<li>
For insertion into outgoing: You may initialize Outgoing with OutOptions::BINARY_MODE to initially set binary mode, otherwise text mode is set. <div class="fragment"><pre class="fragment"><a class="code" href="classZmqMessage_1_1Outgoing.html">ZmqMessage::Outgoing&lt;ZmqMessage::XRouting&gt;</a> outgoing(
  sock, <a class="code" href="structZmqMessage_1_1OutOptions.html#ada297235a6adb7dc637eab6e8cbe1b3">ZmqMessage::OutOptions::NONBLOCK</a> | <a class="code" href="structZmqMessage_1_1OutOptions.html#7e32e290737ff0f3183b00c172bb291a">ZmqMessage::OutOptions::BINARY_MODE</a>);

<span class="comment">//then use Text and Binary manipulators:</span>
<span class="keywordtype">long</span> <span class="keywordtype">id</span> = 1;

outgoing &lt;&lt; <span class="keywordtype">id</span> <span class="comment">//insert binary</span>
  &lt;&lt; <a class="code" href="namespaceZmqMessage.html#60e56a3c40f23f5f62705e2c3a15d6a4">ZmqMessage::Text</a> <span class="comment">//switch to text</span>
  &lt;&lt; <span class="stringliteral">"SET_VALUE"</span>
  &lt;&lt; <a class="code" href="namespaceZmqMessage.html#8b7a75f7f251ba1e0da8b4c7c26b627f">ZmqMessage::Binary</a> &lt;&lt; 999; <span class="comment">//again binary</span>
</pre></div>  </li>
<li>
For all: When you need a particular type to be ALWAYS sent/received/iterated in either binary or text form (independent on current stream state), you may use any of two ways for it.<p>
1. Declare your 'binary' types with <code>raw_mark</code> field. <div class="fragment"><pre class="fragment"><span class="keyword">struct </span><a class="code" href="structSomeBinaryData.html">SomeBinaryData</a>
{
  <span class="keyword">typedef</span> <span class="keywordtype">void</span> raw_mark;

  <span class="keywordtype">int</span> f1;
  <span class="keywordtype">char</span> f2[20];
};
</pre></div><p>
2. Declare particular types as 'binary' using <a class="el" href="MetaTypes_8hpp.html#708fa0f56f2cde439b40a924f99be335">ZMQMESSAGE_BINARY_TYPE</a> or as text using <a class="el" href="MetaTypes_8hpp.html#0a4d424739f1cd0a10687051060289ed">ZMQMESSAGE_TEXT_TYPE</a> macros. <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>OtherBinaryData
{
  <span class="keywordtype">int</span> aa;
  <span class="keywordtype">char</span>[100] data;
};
<a class="code" href="MetaTypes_8hpp.html#708fa0f56f2cde439b40a924f99be335">ZMQMESSAGE_BINARY_TYPE</a>(OtherBinaryData);

<span class="comment">//always send/receive 'long' as text.</span>
<a class="code" href="MetaTypes_8hpp.html#0a4d424739f1cd0a10687051060289ed">ZMQMESSAGE_TEXT_TYPE</a>(<span class="keywordtype">long</span>);
</pre></div> Actually, these macros create a specialization of traits type <a class="el" href="structZmqMessage_1_1Private_1_1IsRaw.html">ZmqMessage::Private::IsRaw</a> for the type specified.<p>
See example <a class="el" href="zserialize_8cpp.html">zserialize.cpp</a> for details. </li>
</ul>

<hr style="height: 3px;">

<div class="zm_greynote">
ZmqMessage 0.1 &mdash; open source software, <a href="mailto:support@zmqmessage.org">support@zmqmessage.org</a>
</div>

</body>
</html>
